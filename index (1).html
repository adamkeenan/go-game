<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Go Game - 9√ó9</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body, #root { height: 100%; width: 100%; }
    body { font-family: system-ui, -apple-system, sans-serif; }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useCallback, useMemo } = React;

    const BOARD_SIZE = 9;
    const KOMI = 6.5;
    const EMPTY = null;
    const BLACK = 'black';
    const WHITE = 'white';

    // Game phases
    const PLAYING = 'playing';
    const STONE_REMOVAL = 'stone_removal';
    const GAME_OVER = 'game_over';

    function GoGame() {
      const [board, setBoard] = useState(() => 
        Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(EMPTY))
      );
      const [currentPlayer, setCurrentPlayer] = useState(BLACK);
      const [captures, setCaptures] = useState({ black: 0, white: 0 });
      const [previousBoard, setPreviousBoard] = useState(null);
      const [consecutivePasses, setConsecutivePasses] = useState(0);
      const [gamePhase, setGamePhase] = useState(PLAYING);
      const [markedDead, setMarkedDead] = useState(new Set());
      const [showPassConfirm, setShowPassConfirm] = useState(false);
      const [finalScore, setFinalScore] = useState(null);

      // Get all connected stones of the same color (flood fill)
      const getGroup = useCallback((boardState, row, col, color, visited = new Set()) => {
        const key = `${row},${col}`;
        if (visited.has(key)) return [];
        if (row < 0 || row >= BOARD_SIZE || col < 0 || col >= BOARD_SIZE) return [];
        if (boardState[row][col] !== color) return [];

        visited.add(key);
        const group = [{ row, col }];
        
        const neighbors = [
          [row - 1, col],
          [row + 1, col],
          [row, col - 1],
          [row, col + 1]
        ];

        for (const [nr, nc] of neighbors) {
          group.push(...getGroup(boardState, nr, nc, color, visited));
        }

        return group;
      }, []);

      // Count liberties for a group
      const countLiberties = useCallback((boardState, group) => {
        const liberties = new Set();
        
        for (const { row, col } of group) {
          const neighbors = [
            [row - 1, col],
            [row + 1, col],
            [row, col - 1],
            [row, col + 1]
          ];

          for (const [nr, nc] of neighbors) {
            if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE) {
              if (boardState[nr][nc] === EMPTY) {
                liberties.add(`${nr},${nc}`);
              }
            }
          }
        }

        return liberties.size;
      }, []);

      // Check if boards are equal (for ko rule)
      const boardsEqual = useCallback((board1, board2) => {
        if (!board1 || !board2) return false;
        for (let i = 0; i < BOARD_SIZE; i++) {
          for (let j = 0; j < BOARD_SIZE; j++) {
            if (board1[i][j] !== board2[i][j]) return false;
          }
        }
        return true;
      }, []);

      // Deep copy board
      const copyBoard = useCallback((boardState) => {
        return boardState.map(row => [...row]);
      }, []);

      // Try to place a stone and return the new board state (or null if invalid)
      const tryPlaceStone = useCallback((boardState, row, col, color) => {
        if (boardState[row][col] !== EMPTY) return null;

        const newBoard = copyBoard(boardState);
        newBoard[row][col] = color;

        const opponent = color === BLACK ? WHITE : BLACK;
        let capturedStones = 0;

        // Check all adjacent opponent groups for capture
        const neighbors = [
          [row - 1, col],
          [row + 1, col],
          [row, col - 1],
          [row, col + 1]
        ];

        const checkedGroups = new Set();
        for (const [nr, nc] of neighbors) {
          if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE) {
            if (newBoard[nr][nc] === opponent) {
              const groupKey = `${nr},${nc}`;
              if (!checkedGroups.has(groupKey)) {
                const group = getGroup(newBoard, nr, nc, opponent);
                group.forEach(g => checkedGroups.add(`${g.row},${g.col}`));
                
                if (countLiberties(newBoard, group) === 0) {
                  // Capture this group
                  for (const { row: gr, col: gc } of group) {
                    newBoard[gr][gc] = EMPTY;
                    capturedStones++;
                  }
                }
              }
            }
          }
        }

        // Check if the placed stone's group has liberties (suicide rule)
        const ownGroup = getGroup(newBoard, row, col, color);
        if (countLiberties(newBoard, ownGroup) === 0) {
          // Suicide move - only allowed if it captured something
          if (capturedStones === 0) {
            return null;
          }
        }

        return { newBoard, capturedStones };
      }, [copyBoard, getGroup, countLiberties]);

      // Place a stone
      const placeStone = useCallback((row, col) => {
        if (gamePhase !== PLAYING) return;

        const result = tryPlaceStone(board, row, col, currentPlayer);
        if (!result) return; // Invalid move

        const { newBoard, capturedStones } = result;

        // Check ko rule
        if (boardsEqual(newBoard, previousBoard)) return;

        // Valid move - update state
        setPreviousBoard(copyBoard(board));
        setBoard(newBoard);
        setCaptures(prev => ({
          ...prev,
          [currentPlayer]: prev[currentPlayer] + capturedStones
        }));
        setCurrentPlayer(currentPlayer === BLACK ? WHITE : BLACK);
        setConsecutivePasses(0);
      }, [board, currentPlayer, gamePhase, previousBoard, tryPlaceStone, boardsEqual, copyBoard]);

      // Pass turn
      const handlePass = useCallback(() => {
        if (gamePhase !== PLAYING) return;
        
        setShowPassConfirm(false);
        const newPasses = consecutivePasses + 1;
        
        if (newPasses >= 2) {
          // Both players passed - enter stone removal phase
          setGamePhase(STONE_REMOVAL);
        } else {
          setConsecutivePasses(newPasses);
          setCurrentPlayer(currentPlayer === BLACK ? WHITE : BLACK);
        }
      }, [gamePhase, consecutivePasses, currentPlayer]);

      // Toggle dead stone marking
      const toggleDeadStone = useCallback((row, col) => {
        if (gamePhase !== STONE_REMOVAL) return;
        if (board[row][col] === EMPTY) return;

        // Get the entire group
        const group = getGroup(board, row, col, board[row][col]);
        const newMarked = new Set(markedDead);

        // Toggle all stones in the group
        const firstKey = `${group[0].row},${group[0].col}`;
        const isCurrentlyMarked = markedDead.has(firstKey);

        for (const { row: gr, col: gc } of group) {
          const key = `${gr},${gc}`;
          if (isCurrentlyMarked) {
            newMarked.delete(key);
          } else {
            newMarked.add(key);
          }
        }

        setMarkedDead(newMarked);
      }, [gamePhase, board, markedDead, getGroup]);

      // Calculate territory using flood fill
      const calculateTerritory = useCallback((boardState, deadStones) => {
        const visited = new Set();
        const territory = { black: 0, white: 0 };

        const floodFillTerritory = (startRow, startCol) => {
          const emptyPoints = [];
          const borderingColors = new Set();
          const stack = [[startRow, startCol]];
          const localVisited = new Set();

          while (stack.length > 0) {
            const [row, col] = stack.pop();
            const key = `${row},${col}`;

            if (localVisited.has(key)) continue;
            if (row < 0 || row >= BOARD_SIZE || col < 0 || col >= BOARD_SIZE) continue;

            const stone = boardState[row][col];
            const isDead = deadStones.has(key);

            if (stone !== EMPTY && !isDead) {
              borderingColors.add(stone);
              continue;
            }

            localVisited.add(key);
            if (stone === EMPTY) {
              emptyPoints.push({ row, col });
            }

            stack.push([row - 1, col], [row + 1, col], [row, col - 1], [row, col + 1]);
          }

          // Mark all visited points as globally visited
          localVisited.forEach(k => visited.add(k));

          // Only count territory if bordered by exactly one color
          if (borderingColors.size === 1) {
            const owner = [...borderingColors][0];
            return { owner, points: emptyPoints.length };
          }

          return { owner: null, points: 0 };
        };

        for (let row = 0; row < BOARD_SIZE; row++) {
          for (let col = 0; col < BOARD_SIZE; col++) {
            const key = `${row},${col}`;
            if (visited.has(key)) continue;
            if (boardState[row][col] !== EMPTY) continue;

            const result = floodFillTerritory(row, col);
            if (result.owner) {
              territory[result.owner] += result.points;
            }
          }
        }

        return territory;
      }, []);

      // Finalize score
      const finalizeScore = useCallback(() => {
        // Count dead stones as prisoners
        let blackDeadCount = 0;
        let whiteDeadCount = 0;

        markedDead.forEach(key => {
          const [row, col] = key.split(',').map(Number);
          if (board[row][col] === BLACK) blackDeadCount++;
          if (board[row][col] === WHITE) whiteDeadCount++;
        });

        // Calculate territory
        const territory = calculateTerritory(board, markedDead);

        // Japanese scoring: Territory + Prisoners
        const blackScore = territory.black + captures.black + whiteDeadCount;
        const whiteScore = territory.white + captures.white + blackDeadCount + KOMI;

        setFinalScore({
          black: {
            territory: territory.black,
            prisoners: captures.black + whiteDeadCount,
            total: blackScore
          },
          white: {
            territory: territory.white,
            prisoners: captures.white + blackDeadCount,
            komi: KOMI,
            total: whiteScore
          },
          winner: blackScore > whiteScore ? BLACK : (whiteScore > blackScore ? WHITE : 'tie')
        });

        setGamePhase(GAME_OVER);
      }, [board, markedDead, captures, calculateTerritory]);

      // New game
      const newGame = useCallback(() => {
        setBoard(Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(EMPTY)));
        setCurrentPlayer(BLACK);
        setCaptures({ black: 0, white: 0 });
        setPreviousBoard(null);
        setConsecutivePasses(0);
        setGamePhase(PLAYING);
        setMarkedDead(new Set());
        setShowPassConfirm(false);
        setFinalScore(null);
      }, []);

      // Handle intersection click
      const handleIntersectionClick = useCallback((row, col) => {
        if (gamePhase === PLAYING) {
          placeStone(row, col);
        } else if (gamePhase === STONE_REMOVAL) {
          toggleDeadStone(row, col);
        }
      }, [gamePhase, placeStone, toggleDeadStone]);

      // Generate star points for the board
      const starPoints = useMemo(() => {
        // For 9x9 board, star points at corners (2,2) and center (4,4)
        return [
          { row: 2, col: 2 },
          { row: 2, col: 6 },
          { row: 6, col: 2 },
          { row: 6, col: 6 },
          { row: 4, col: 4 }
        ];
      }, []);

      // Board dimensions
      const BOARD_PADDING = 24;
      const CELL_SIZE = 40;
      const STONE_SIZE = 36;
      const GRID_SIZE = CELL_SIZE * (BOARD_SIZE - 1);
      const BOARD_TOTAL_SIZE = GRID_SIZE + (BOARD_PADDING * 2);

      return (
        <div className="min-h-screen flex flex-col items-center justify-center p-4" style={{
          background: 'linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%)'
        }}>
          {/* Header */}
          <div className="w-full max-w-md mb-4">
            <h1 className="text-2xl font-bold text-center text-amber-100 tracking-wider" style={{
              fontFamily: "'Noto Serif', Georgia, serif",
              textShadow: '2px 2px 4px rgba(0,0,0,0.5)'
            }}>
              Á¢Å Go
            </h1>
          </div>

          {/* Status Bar */}
          <div className="w-full max-w-md mb-3 px-2">
            <div className="flex justify-between items-center text-sm">
              {/* Black Info */}
              <div className={`flex items-center gap-2 px-3 py-2 rounded-lg transition-all duration-300 ${
                currentPlayer === BLACK && gamePhase === PLAYING ? 'bg-amber-900/50 ring-2 ring-amber-400' : 'bg-black/30'
              }`}>
                <div className="w-5 h-5 rounded-full bg-gradient-to-br from-gray-700 to-black shadow-lg border border-gray-600" />
                <span className="text-amber-100 font-medium">Black</span>
                <span className="text-amber-300 text-xs">‚¨§ {captures.black}</span>
              </div>

              {/* White Info */}
              <div className={`flex items-center gap-2 px-3 py-2 rounded-lg transition-all duration-300 ${
                currentPlayer === WHITE && gamePhase === PLAYING ? 'bg-amber-900/50 ring-2 ring-amber-400' : 'bg-black/30'
              }`}>
                <div className="w-5 h-5 rounded-full bg-gradient-to-br from-white to-gray-200 shadow-lg border border-gray-300" />
                <span className="text-amber-100 font-medium">White</span>
                <span className="text-amber-300 text-xs">‚¨§ {captures.white}</span>
              </div>
            </div>

            {/* Turn/Phase Indicator */}
            <div className="mt-2 text-center">
              {gamePhase === PLAYING && (
                <p className="text-amber-200 text-sm">
                  {currentPlayer === BLACK ? "Black" : "White"}'s turn
                </p>
              )}
              {gamePhase === STONE_REMOVAL && (
                <p className="text-amber-300 text-sm font-medium animate-pulse">
                  Mark dead stones, then finalize
                </p>
              )}
              {gamePhase === GAME_OVER && (
                <p className="text-amber-400 text-sm font-bold">
                  Game Over
                </p>
              )}
            </div>
          </div>

          {/* Board Container */}
          <div 
            className="relative rounded-xl shadow-2xl"
            style={{
              width: BOARD_TOTAL_SIZE,
              height: BOARD_TOTAL_SIZE,
              background: 'linear-gradient(145deg, #c4a35a 0%, #b8956e 50%, #a67c52 100%)',
              boxShadow: '0 20px 50px rgba(0,0,0,0.5), inset 0 2px 10px rgba(255,255,255,0.2)'
            }}
          >
            {/* Wood grain texture overlay */}
            <div className="absolute inset-0 rounded-xl opacity-20 pointer-events-none" style={{
              backgroundImage: `repeating-linear-gradient(
                90deg,
                transparent,
                transparent 20px,
                rgba(139, 90, 43, 0.3) 20px,
                rgba(139, 90, 43, 0.3) 21px
              )`
            }} />

            {/* SVG Grid */}
            <svg 
              className="absolute pointer-events-none"
              style={{
                left: BOARD_PADDING,
                top: BOARD_PADDING,
                width: GRID_SIZE,
                height: GRID_SIZE
              }}
            >
              {/* Horizontal lines */}
              {Array.from({ length: BOARD_SIZE }).map((_, i) => (
                <line
                  key={`h-${i}`}
                  x1="0"
                  y1={i * CELL_SIZE}
                  x2={GRID_SIZE}
                  y2={i * CELL_SIZE}
                  stroke="#4a3728"
                  strokeWidth="1"
                />
              ))}
              {/* Vertical lines */}
              {Array.from({ length: BOARD_SIZE }).map((_, i) => (
                <line
                  key={`v-${i}`}
                  x1={i * CELL_SIZE}
                  y1="0"
                  x2={i * CELL_SIZE}
                  y2={GRID_SIZE}
                  stroke="#4a3728"
                  strokeWidth="1"
                />
              ))}
              {/* Star points */}
              {starPoints.map(({ row, col }) => (
                <circle
                  key={`star-${row}-${col}`}
                  cx={col * CELL_SIZE}
                  cy={row * CELL_SIZE}
                  r="4"
                  fill="#4a3728"
                />
              ))}
            </svg>

            {/* Clickable intersections and stones */}
            {board.map((row, rowIndex) =>
              row.map((cell, colIndex) => {
                const isDead = markedDead.has(`${rowIndex},${colIndex}`);
                
                return (
                  <div
                    key={`${rowIndex}-${colIndex}`}
                    className="absolute cursor-pointer flex items-center justify-center"
                    onClick={() => handleIntersectionClick(rowIndex, colIndex)}
                    style={{
                      left: BOARD_PADDING + (colIndex * CELL_SIZE) - (CELL_SIZE / 2),
                      top: BOARD_PADDING + (rowIndex * CELL_SIZE) - (CELL_SIZE / 2),
                      width: CELL_SIZE,
                      height: CELL_SIZE
                    }}
                  >
                    {/* Stone */}
                    {cell && (
                      <div
                        className={`rounded-full transition-all duration-200 flex items-center justify-center ${
                          isDead ? 'opacity-40 scale-90' : ''
                        }`}
                        style={{
                          width: STONE_SIZE,
                          height: STONE_SIZE,
                          background: cell === BLACK
                            ? 'radial-gradient(ellipse at 30% 20%, #555 0%, #222 40%, #000 100%)'
                            : 'radial-gradient(ellipse at 30% 20%, #fff 0%, #f0f0f0 40%, #ccc 100%)',
                          boxShadow: cell === BLACK
                            ? '3px 3px 6px rgba(0,0,0,0.6), inset -2px -2px 4px rgba(80,80,80,0.3)'
                            : '3px 3px 6px rgba(0,0,0,0.3), inset -2px -2px 4px rgba(150,150,150,0.5)',
                          border: cell === BLACK ? '1px solid #333' : '1px solid #bbb'
                        }}
                      >
                        {/* Dead stone X marker */}
                        {isDead && (
                          <span className="text-red-500 font-bold text-xl" style={{
                            textShadow: '0 0 4px rgba(255,0,0,0.5)'
                          }}>‚úï</span>
                        )}
                      </div>
                    )}
                  </div>
                );
              })
            )}
          </div>

          {/* Controls */}
          <div className="w-full max-w-md mt-4 px-2">
            {gamePhase === PLAYING && (
              <div className="flex gap-3 justify-center">
                {!showPassConfirm ? (
                  <button
                    onClick={() => setShowPassConfirm(true)}
                    className="px-6 py-2 bg-amber-800/80 hover:bg-amber-700 text-amber-100 rounded-lg transition-all text-sm font-medium shadow-lg"
                  >
                    Pass
                  </button>
                ) : (
                  <div className="flex items-center gap-2 bg-amber-900/60 px-4 py-2 rounded-lg">
                    <span className="text-amber-100 text-sm">Pass turn?</span>
                    <button
                      onClick={handlePass}
                      className="px-4 py-1 bg-green-700 hover:bg-green-600 text-white rounded text-sm"
                    >
                      Yes
                    </button>
                    <button
                      onClick={() => setShowPassConfirm(false)}
                      className="px-4 py-1 bg-red-700 hover:bg-red-600 text-white rounded text-sm"
                    >
                      No
                    </button>
                  </div>
                )}
                <button
                  onClick={newGame}
                  className="px-6 py-2 bg-slate-700/80 hover:bg-slate-600 text-slate-100 rounded-lg transition-all text-sm font-medium shadow-lg"
                >
                  New Game
                </button>
              </div>
            )}

            {gamePhase === STONE_REMOVAL && (
              <div className="flex flex-col gap-3 items-center">
                <p className="text-amber-200/80 text-xs text-center">
                  Tap stone groups to mark them as dead
                </p>
                <div className="flex gap-3">
                  <button
                    onClick={finalizeScore}
                    className="px-6 py-2 bg-green-700 hover:bg-green-600 text-white rounded-lg transition-all text-sm font-medium shadow-lg"
                  >
                    Finalize Score
                  </button>
                  <button
                    onClick={newGame}
                    className="px-6 py-2 bg-slate-700/80 hover:bg-slate-600 text-slate-100 rounded-lg transition-all text-sm font-medium shadow-lg"
                  >
                    New Game
                  </button>
                </div>
              </div>
            )}

            {gamePhase === GAME_OVER && finalScore && (
              <div className="bg-black/40 rounded-xl p-4 backdrop-blur-sm">
                {/* Winner Banner */}
                <div className="text-center mb-4">
                  <p className="text-2xl font-bold text-amber-300" style={{
                    fontFamily: "'Noto Serif', Georgia, serif"
                  }}>
                    {finalScore.winner === 'tie' 
                      ? 'ü§ù Tie Game!' 
                      : `${finalScore.winner === BLACK ? '‚ö´ Black' : '‚ö™ White'} Wins!`}
                  </p>
                </div>

                {/* Score Details */}
                <div className="grid grid-cols-2 gap-4 text-sm mb-4">
                  {/* Black Score */}
                  <div className="bg-gray-900/50 rounded-lg p-3">
                    <div className="flex items-center gap-2 mb-2">
                      <div className="w-4 h-4 rounded-full bg-gradient-to-br from-gray-700 to-black" />
                      <span className="text-amber-100 font-medium">Black</span>
                    </div>
                    <div className="text-amber-200/80 text-xs space-y-1">
                      <p>Territory: {finalScore.black.territory}</p>
                      <p>Prisoners: {finalScore.black.prisoners}</p>
                      <p className="text-amber-300 font-bold pt-1 border-t border-amber-900">
                        Total: {finalScore.black.total}
                      </p>
                    </div>
                  </div>

                  {/* White Score */}
                  <div className="bg-gray-100/10 rounded-lg p-3">
                    <div className="flex items-center gap-2 mb-2">
                      <div className="w-4 h-4 rounded-full bg-gradient-to-br from-white to-gray-200" />
                      <span className="text-amber-100 font-medium">White</span>
                    </div>
                    <div className="text-amber-200/80 text-xs space-y-1">
                      <p>Territory: {finalScore.white.territory}</p>
                      <p>Prisoners: {finalScore.white.prisoners}</p>
                      <p>Komi: +{finalScore.white.komi}</p>
                      <p className="text-amber-300 font-bold pt-1 border-t border-amber-900">
                        Total: {finalScore.white.total}
                      </p>
                    </div>
                  </div>
                </div>

                <button
                  onClick={newGame}
                  className="w-full px-6 py-3 bg-amber-700 hover:bg-amber-600 text-white rounded-lg transition-all font-medium shadow-lg"
                >
                  Play Again
                </button>
              </div>
            )}
          </div>

          {/* Footer */}
          <div className="mt-4 text-amber-200/40 text-xs text-center">
            9√ó9 ‚Ä¢ Japanese Rules ‚Ä¢ Komi {KOMI}
          </div>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<GoGame />);
  </script>
</body>
</html>
